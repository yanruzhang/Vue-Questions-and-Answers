## Vue Questions
---
### 1.20 第一题
### v-if和v-for哪个优先级高？如果两个同时出现，应该怎么优化得到更好的性能？
  
#### v-for优先级高于v-if  

#### 优化方法： 
- 对于列表中有需要隐藏的数据的情况： 新建一个计算属性对列表中的数据进行处理，返回过滤后的列表数据
- 对于可能需要隐藏的列表： 将v-if移至v-for元素的父元素上

### 1.21 第二题
### Vue组件data选项为什么必须是个函数而Vue的根实例则没有此限制？
- 一个组件的 data 选项必须是一个函数，因为组件可能被实例化多次，如果data是个函数，则每个实例可以维护一份被返回对象的独立的拷贝。根组件只被实例化一次，所以根组件的data可以是对象。

### 1.22 第三题
### key的作用和原理
- key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能
- 另外，若不设置key还可能在列表更新时引发一些隐藏的bug
- vue中在使用相同标签元素的过渡切换切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不触发过渡效果

### 1.23 第四题
### 怎么理解vue中的diff算法
- diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度O(n)。
- vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。
- vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch.
- diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助key通常可以非常准确找到相同节点，因此整个patch过程非常高效。

### 1.24 第五题
### 对vue组件化的理解
- 组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
- 组件化开发能大幅提高应用开发效率、测试性、复用性等；
- 组件使用按分类有：页面组件、业务组件、通用组件
- vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue;
- vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；
- 合理的划分组件，有助于提高应用性能；
- 组件应该是高内聚、低耦合的；
- 遵循单向数据流的原则。

### 1.25 第六题
### vue设计原则的理解
- 易用性
  - vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。
- 灵活性
  - 渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管应用体积还是学习难度都是一个逐渐增加的和平曲线。
- 高效性
  - 超快的虚拟DOM和diff算法使我们的应用拥有最佳的性能表现。
  - 追求高效的过程还在技术，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。

### 1.26 第七题
### vue为什么要求组件模板只能有一个根元素
- new Vue({ el: '#app' })
- 单文件组件中，template下的元素div，其实就是“树”状结构中的“根”
  - 在webpack搭建的vue开发环境下，使用单文件组件时：  
    例：   
    ```vue
      <template>
        <div>
          ...
        </div>
      </template>
    ```
    template标签有三个特性：
      - 隐藏性：该标签不会显示在页面的任何地方，即便里面有多少内容，它永远都是隐藏的状态，设置了display: none；
      - 任意性：该标签可以写在任何地方，甚至是head、body、script标签内；
- diff中patchvnode方法，用来比较新旧节点时需要（该方法不会遍历根元素）

### 1.27 第八题
### 对MVC、MVP和MVVM的理解
- 这三者都是框架模式，它们设计的目标都是为了解决Modal和View的耦合问题。
- MVC模式出现较早主要应用在后端，如spring MVC、ASP.NET MVC等，在前端领域的早期也有应用，如Backbone.js。它的优点是分层清晰，缺点是数据流乱，灵活性带来的维护性问题。
- MVP模式是MVC模式的进化形式，Presenter作为中间层负责MV通信，解决两者耦合问题，但P层过于臃肿会导致维护问题。
- MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。

### 1.28 第九题
### vue组件之间的通信
- vue组件通信的几种方式
  - props
  - $emit/$on 事件总线
  - vuex
